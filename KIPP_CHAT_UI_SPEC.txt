
# KIPP FRONTEND: CHAT UI & MESSAGE SPECIFICATION
Version: 2.1 (Fluid Typography & Generative Widgets)

================================================================================
PART 1: THE MESSAGE ARCHITECTURE
================================================================================

## 1.1 The Layout Philosophy
The Chat UI in KIPP behaves differently than standard messengers. It is not a list of boxes; it is a **continuous document stream**.
- **User Messages**: Treated as "annotations" or "prompts" from the side. They are distinct, boxed, and aligned to the right to visually separate the user's intent from the AI's creation.
- **AI Responses**: Treated as "content". They use the full width, transparent backgrounds, and rich typography to look like a generated article or report rather than a chat bubble.

## 1.2 User Message Design
- **Shape**: `rounded-3xl` with `rounded-br-lg`. The sharp bottom-right corner acts as a subtle "speech beak" pointing to the user.
- **Surface**: `bg-surface-l1` (White in Light Mode, #212121 in Dark Mode).
- **Border**: `border border-border`.
- **Typography**: `text-[16px]` leading-relaxed.
- **Interaction**: Group hover reveals the "Copy" icon.

## 1.3 AI Message Design
- **Container**: Full width, left-aligned.
- **Background**: Transparent (`bg-transparent`). This reduces visual clutter when reading long text.
- **Typography**: `prose dark:prose-invert`. This uses Tailwind Typography to automatically style headers, lists, and paragraphs with perfect vertical rhythm.
- **The "Thinking" Block**:
  - A collapsible accordion style.
  - **Visual**: `border-l-2 border-border` (A subtle vertical line).
  - **State**: If the AI is currently "thinking" (streaming), the Brain icon pulses. Once done, it collapses to save space.

## 1.4 Rich Content (Generative UI)
KIPP doesn't just output text. It injects "Widgets" into the stream:
- **Stock Cards**: Dark-themed financial cards with green/red trend indicators.
- **Sources**: Pill-shaped buttons that expand into a modal.
- **Code Blocks**: Mac-window style containers with execution controls.

================================================================================
PART 2: CHAT MESSAGE COMPONENT
================================================================================

This component is the heart of the render loop. It parses raw text, identifies "Thinking" tags, renders Markdown, and injects Tool calls.

## Source Code (`components/ChatMessage.tsx`)

```tsx
import React, { useState, useMemo, useEffect } from 'react';
import { marked } from 'marked';
import type { Message, AIStatus, GroundingChunk } from '../types';
import { MessageType } from '../types';
import {
    BrainIcon, 
    ChevronDownIcon, 
    CheckIcon, 
    GitForkIcon, 
    MessageRefreshIcon, 
    MessageCopyIcon, 
    CornerDownRightIcon, 
    SearchIcon, 
    MapPinIcon
} from './icons';
import { CodeExecutor } from './CodeExecutor';
import ImageGallery from './ImageGallery';
import GroundingSources from './GroundingSources';
import GenerativeUI from './GenerativeUI';
import GeneratingLoader from './GeneratingLoader';

// --- Types & Interfaces ---

type ExecutionResult = {
  output: string | null;
  error: string;
  type: 'string' | 'image-base64' | 'plotly-json' | 'error';
  downloadableFile?: { filename: string; mimetype: string; data: string; };
};

interface ChatMessageProps {
    message: Message;
    onRegenerate: (messageId: string) => void;
    onFork: (messageId: string) => void;
    isLoading: boolean;
    aiStatus: AIStatus;
    executionResults: Record<string, ExecutionResult>;
    onStoreExecutionResult: (messageId: string, partIndex: number, result: ExecutionResult) => void;
    onFixRequest: (code: string, lang: string, error: string) => void;
    onStopExecution: () => void;
    isPythonReady: boolean;
    t: (key: string) => string;
    onOpenLightbox: (images: any[], startIndex: number) => void;
    isLast: boolean;
    onSendSuggestion: (text: string) => void;
}

// --- Helper Functions ---

const isImageFile = (mimeType: string) => mimeType.startsWith('image/');

const getTextFromMessage = (content: any): string => {
    if (typeof content === 'string') return content;
    return '';
}

// Custom parser to handle LaTeX math within Markdown
const textToHtml = (text: string): string => {
    if (!text) return '';
    const placeholders: { [key:string]: string } = {};
    let placeholderId = 0;
    // Regex to protect Math blocks from Markdown parser
    const mathRegex = /(\$\$[\s\S]+?\$\$|\\\[[\s\S]+?\\\]|\\\(.+?\\\)|(\$[^\$\n\r]+?\$))/g;
    
    const textWithPlaceholders = text.replace(mathRegex, (match) => {
        const id = `__KIPP_PLACEHOLDER_${placeholderId++}__`;
        placeholders[id] = match;
        return id;
    });
    
    let html = marked.parse(textWithPlaceholders, { breaks: true, gfm: true }) as string;
    
    // Restore math blocks
    for (const id in placeholders) {
        html = html.replace(id, placeholders[id]);
    }
    return html;
};

// --- Sub-Components ---

const SearchStatus: React.FC<{ sources?: GroundingChunk[], resultCount?: number }> = ({ sources, resultCount }) => {
    const [step, setStep] = useState(0); 
    useEffect(() => {
        if (sources && sources.length > 0) setStep(1);
    }, [sources]);

    return (
        <div className="flex flex-col gap-1 cursor-crosshair text-sm mb-4 animate-fade-in-up">
            <div className="flex flex-row items-center gap-2 cursor-pointer hover:opacity-80">
                <div className="flex flex-row items-center gap-2 text-foreground">
                    <SearchIcon className={`size-4 ${step === 0 ? 'animate-pulse text-accent-blue' : 'text-muted-foreground'}`} />
                    <div className={step === 0 ? 'font-medium' : 'text-muted-foreground'}>Searching the web</div>
                </div>
                {step === 1 && (
                    <div className="text-muted-foreground text-xs font-mono ml-1">
                        {resultCount && resultCount > 0 ? <>{resultCount} results</> : `${sources?.length || 0} sources`}
                    </div>
                )}
            </div>
            {step === 1 && sources && sources.length > 0 && (
                <div className="flex flex-row items-center gap-2 cursor-pointer hover:opacity-80 animate-fade-in-up">
                    <div className="flex flex-row items-center gap-2 text-foreground">
                        {/* Globe/Browsing Icon */}
                        <div className="size-4 rounded-full bg-accent-blue/10 flex items-center justify-center">
                            <div className="size-2 bg-accent-blue rounded-full animate-pulse"></div>
                        </div>
                        <div className="font-medium">Browsing</div>
                    </div>
                    <div className="text-muted-foreground text-xs truncate max-w-[200px]">
                        {'web' in sources[0] ? sources[0].web.uri : (sources[0] as any).maps.uri}
                    </div>
                </div>
            )}
        </div>
    );
};

const GallerySearchLoader: React.FC<{ query: string, onOpenLightbox: (images: any[], index: number) => void }> = ({ query, onOpenLightbox }) => {
    const [images, setImages] = useState<any[]>([]);
    const [loading, setLoading] = useState(true);

    useEffect(() => {
        const fetchImages = async () => {
            try {
                setLoading(true);
                const res = await fetch('/api/chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ imageSearchQuery: query })
                });
                const data = await res.json();
                if (data.images && Array.isArray(data.images)) {
                    setImages(data.images.map((url: string) => ({ url, alt: query })));
                }
            } catch (e) {
                // Fail silently
            } finally {
                setLoading(false);
            }
        }
        if (query) fetchImages();
    }, [query]);

    if (loading) return (
         <div className="grid grid-cols-3 gap-1.5 my-2 max-w-xl">
             {[1,2,3].map(i => <div key={i} className="aspect-square bg-surface-l2 animate-pulse rounded-lg" />)}
         </div>
    );
    
    if (images.length === 0) return null;

    return <ImageGallery images={images} onImageClick={(i) => onOpenLightbox(images, i)} />;
}

// --- Main Component ---

const ChatMessage: React.FC<ChatMessageProps> = ({ 
    message, 
    onRegenerate, 
    onFork, 
    isLoading, 
    aiStatus, 
    executionResults, 
    onStoreExecutionResult, 
    onFixRequest, 
    onStopExecution, 
    isPythonReady, 
    t, 
    onOpenLightbox, 
    isLast, 
    onSendSuggestion 
}) => {
    const isUser = message.type === MessageType.USER;
    const isError = message.type === MessageType.ERROR;
    const [isThinkingOpen, setIsThinkingOpen] = useState(false);
    const [isCopied, setIsCopied] = useState(false);

    // Auto-open thinking block while streaming
    useEffect(() => {
        if (aiStatus === 'thinking' && isLast) setIsThinkingOpen(true);
    }, [aiStatus, isLast]);

    const messageText = useMemo(() => getTextFromMessage(message.content), [message.content]);

    // Parse <thinking> and <suggestions> tags out of the raw text
    const { parsedThinkingText, parsedResponseText, hasThinkingTag, suggestions } = useMemo(() => {
        if (isUser) return { parsedThinkingText: null, parsedResponseText: messageText, hasThinkingTag: false, suggestions: [] };
        
        let text = messageText || '';
        let extractedSuggestions: string[] = [];
        
        // Extract Suggestions
        const suggestionsMatch = text.match(/<suggestions>(.*?)<\/suggestions>/s);
        if (suggestionsMatch) {
            try { extractedSuggestions = JSON.parse(suggestionsMatch[1]); } catch (e) { }
            text = text.replace(/<suggestions>.*?<\/suggestions>/s, '').trim();
        }
        
        // Extract Thinking Process
        const thinkingMatch = text.match(/<thinking>([\s\S]*?)(?:<\/thinking>|$)/);
        let thinking = null;
        let response = text;
        let hasTag = false;
        
        if (text.includes('<thinking>')) {
            hasTag = true;
            if (thinkingMatch) {
                thinking = thinkingMatch[1].trim();
                if (text.includes('</thinking>')) {
                    response = text.split('</thinking>')[1]?.trim() || '';
                } else {
                    response = ''; // Still thinking
                }
            }
        }
        
        return { parsedThinkingText: thinking, parsedResponseText: response, hasThinkingTag: hasTag, suggestions: extractedSuggestions };
    }, [messageText, isUser]);

    // Split response into Renderable Parts (Text vs Code Blocks vs Galleries)
    const renderableContent = useMemo(() => {
        const textToRender = parsedResponseText;
        if (!textToRender) return [];
        
        // Regex to split by Code Blocks OR Gallery Tags
        const blockRegex = /(```[\w\s\S]*?```|!gallery\[".*?"\])/g;
        let finalParts: any[] = [];
        let partIndex = 0;
        
        textToRender.split(blockRegex).filter(Boolean).forEach(part => {
            if (part.startsWith('```')) {
                const codeMatch = /```([\w-]+)?(?:[^\n]*)?\n([\s\S]*?)```/.exec(part);
                if (codeMatch) {
                    const lang = codeMatch[1] || 'plaintext';
                    const code = codeMatch[2];
                    
                    if (lang === 'json-gallery') {
                         try {
                            const galleryData = JSON.parse(code);
                            if (galleryData.type === 'image_gallery' && Array.isArray(galleryData.images)) {
                                finalParts.push({ type: 'gallery', images: galleryData.images });
                            }
                        } catch (e) { }
                    } else {
                        finalParts.push({ type: 'code', lang, code, info: part.split('\n')[0].substring(3).trim(), partIndex: partIndex++ });
                    }
                }
            } else if (part.startsWith('!gallery')) {
                const match = /!gallery\["(.*?)"\]/.exec(part);
                 if (match && match[1]) finalParts.push({ type: 'gallery-search', query: match[1] });
            } else { 
                finalParts.push({ type: 'text', content: part }); 
            }
        });
        return finalParts;
    }, [parsedResponseText]);

    const handleCopy = () => {
        navigator.clipboard.writeText(parsedResponseText).then(() => {
            setIsCopied(true);
            setTimeout(() => setIsCopied(false), 2000);
        });
    };

    // --- RENDER: USER MESSAGE ---
    if (isUser) {
        return (
            <div className="relative group flex flex-col justify-center w-full max-w-[var(--content-max-width)] pb-4 items-end">
                {/* Bubble */}
                <div className="message-bubble relative rounded-3xl text-foreground min-h-7 prose dark:prose-invert break-words bg-surface-l1 border border-border max-w-[100%] @sm/mainview:max-w-[90%] px-4 py-2 rounded-br-lg shadow-sm">
                    <div className="whitespace-pre-wrap leading-relaxed text-[16px]">{messageText}</div>
                </div>
                
                {/* File Attachments */}
                {message.files && message.files.length > 0 && (
                    <div className="flex flex-wrap justify-end gap-2 mt-2">
                        {message.files.map((file, i) => (
                            <div key={i} className="relative group rounded-xl overflow-hidden border border-border">
                                {isImageFile(file.type) 
                                    ? <img src={file.dataUrl} alt={file.name} className="h-20 w-auto object-cover" /> 
                                    : <div className="h-20 w-20 bg-surface-l2 flex items-center justify-center text-xs text-muted-foreground p-2 text-center break-all">{file.name}</div>
                                }
                            </div>
                        ))}
                    </div>
                )}
                
                {/* Copy Action */}
                <div className="flex items-center gap-2 mt-1 px-1">
                     <button className="p-1 hover:bg-surface-l2 rounded-full text-muted-foreground hover:text-foreground transition-colors" title={t('chat.message.copy')} onClick={handleCopy}>
                        {isCopied ? <CheckIcon className="size-3.5 text-green-500" /> : <MessageCopyIcon className="size-3.5" />}
                     </button>
                </div>
            </div>
        );
    }

    // --- RENDER: ERROR MESSAGE ---
    if (isError) {
        return (
            <div className="flex flex-col w-full mb-8 max-w-full">
                <div className="p-4 rounded-xl border border-red-500/20 bg-red-500/5 text-red-500 text-sm">
                    {messageText || "An unknown error occurred."}
                </div>
                <div className="flex items-center space-x-0 mt-2 text-muted-foreground">
                    <button className="p-1 hover:bg-surface-l2 rounded-full" onClick={() => onRegenerate(message.id)} title={t('chat.message.regenerate')}>
                        <MessageRefreshIcon className="size-4" />
                    </button>
                </div>
            </div>
        )
    }

    // --- RENDER: AI RESPONSE ---
    
    // Filter out 'google_search' tool calls as they are handled by SearchStatus or embedded context
    const uiToolCalls = useMemo(() => {
        return (message.toolCalls || []).filter(tc => tc.name !== 'google_search');
    }, [message.toolCalls]);

    const hasToolCalls = uiToolCalls.length > 0;
    const hasText = !!parsedResponseText;
    const hasContent = hasText || hasToolCalls;
    const isActuallyLastLoading = isLast && isLoading;
    
    // Show search status if we are loading and waiting for grounding, or if we have grounding sources but no content yet
    const showSearchUI = (aiStatus === 'searching' && isActuallyLastLoading) || (message.groundingChunks && message.groundingChunks.length > 0 && isActuallyLastLoading && !hasContent);

    return (
        <div className="relative group flex flex-col justify-center w-full max-w-[var(--content-max-width)] pb-4 items-start">
             
             {/* 1. Thinking Accordion */}
             {hasThinkingTag && parsedThinkingText && (
                <div className="mb-2">
                     <div onClick={() => setIsThinkingOpen(!isThinkingOpen)} className="flex items-center gap-2 cursor-pointer text-muted-foreground hover:text-foreground transition-colors w-fit p-1 rounded-lg">
                        <BrainIcon className={`size-4 ${isActuallyLastLoading && aiStatus === 'thinking' ? 'animate-pulse text-accent-blue' : ''}`} />
                        <span className="text-sm font-medium">{t('chat.message.thinking')}</span>
                        <ChevronDownIcon className={`size-4 transition-transform ${isThinkingOpen ? 'rotate-180' : ''}`} />
                    </div>
                    {isThinkingOpen && (
                        <div className="mt-2 pl-3 border-l-2 border-border text-muted-foreground text-sm italic whitespace-pre-wrap animate-fade-in-up">
                            {parsedThinkingText}
                        </div>
                    )}
                </div>
            )}
            
            {/* 2. Search Progress Indicator */}
            {showSearchUI && <SearchStatus sources={message.groundingChunks} resultCount={message.searchResultCount} />}

            {/* 3. Main Content Bubble */}
            <div className={`message-bubble relative rounded-3xl text-foreground prose dark:prose-invert break-words w-full max-w-none px-4 py-2 ${!hasContent ? 'min-h-0 py-0' : 'min-h-7'}`}>
                 
                 {/* Loading Spinner if completely empty */}
                 {!hasContent && isActuallyLastLoading && !parsedThinkingText && !showSearchUI && (
                    <div className="flex items-center gap-2 text-muted-foreground min-h-[28px]">
                        <GeneratingLoader />
                    </div>
                )}

                {/* Generative UI Tools (Stocks, etc) */}
                {hasToolCalls && (
                    <div className="w-full mb-4 space-y-4">
                        {uiToolCalls.map((toolCall, idx) => <GenerativeUI key={idx} toolName={toolCall.name} args={toolCall.args} />)}
                    </div>
                )}

                {/* Text & Code Rendering */}
                {renderableContent.map((part: any, index: number) => {
                    if (part.type === 'code') {
                         const resultKey = `${message.id}_${part.partIndex}`;
                         const result = executionResults[resultKey];
                         const isPython = part.lang === 'python';
                         return (
                            <div key={index} className="w-full my-4 not-prose">
                                <CodeExecutor 
                                    code={part.code} 
                                    lang={part.lang} 
                                    title={part.lang.toUpperCase()} 
                                    isExecutable={['python', 'html'].includes(part.lang.toLowerCase())} 
                                    autorun={isPython && !result} 
                                    onExecutionComplete={(res) => onStoreExecutionResult(message.id, part.partIndex, res)} 
                                    onFixRequest={(err) => onFixRequest(part.code, part.lang, err)} 
                                    persistedResult={result} 
                                    onStopExecution={onStopExecution} 
                                    isPythonReady={isPythonReady} 
                                    isLoading={isLoading} 
                                    t={t} 
                                />
                            </div>
                         );
                    }
                    if (part.type === 'gallery-search') return <GallerySearchLoader key={index} query={part.query} onOpenLightbox={onOpenLightbox} />;
                    if (part.type === 'gallery') return <div key={index} className="my-4"><ImageGallery images={part.images.map((img: string) => ({ url: img, alt: 'Generated Image' }))} onImageClick={(i) => onOpenLightbox(part.images.map((img: string) => ({ url: img, alt: 'Generated Image' })), i)} /></div>;
                    
                    return <div key={index} className="prose dark:prose-invert max-w-none w-full" dangerouslySetInnerHTML={{ __html: textToHtml(part.content) }} />;
                })}
            </div>

            {/* 4. Sources Footer */}
            {message.groundingChunks && message.groundingChunks.length > 0 && !isLoading && (
                <div className="mt-2 flex flex-wrap gap-2">
                    <GroundingSources chunks={message.groundingChunks} t={t} />
                </div>
            )}

            {/* 5. Message Actions (Copy, Retry, Fork) */}
            {!isLoading && (
                <div className="flex items-center gap-2 mt-2 w-full justify-start px-2">
                    <button className="p-1.5 hover:bg-surface-l2 rounded-full text-muted-foreground hover:text-foreground" title={t('chat.message.regenerate')} onClick={() => onRegenerate(message.id)}><MessageRefreshIcon className="size-4" /></button>
                    <button className="p-1.5 hover:bg-surface-l2 rounded-full text-muted-foreground hover:text-foreground" title={t('chat.message.copy')} onClick={handleCopy}>{isCopied ? <CheckIcon className="size-4 text-green-500" /> : <MessageCopyIcon className="size-4" />}</button>
                    <button className="p-1.5 hover:bg-surface-l2 rounded-full text-muted-foreground hover:text-foreground" title={t('chat.message.fork')} onClick={() => onFork(message.id)}><GitForkIcon className="size-4" /></button>
                    {message.generationDuration && <span className="ml-2 text-muted-foreground text-xs select-none font-mono">{(message.generationDuration / 1000).toFixed(1)}s</span>}
                </div>
            )}
            
            {/* 6. AI Suggestions Chips */}
            {isLast && suggestions.length > 0 && !isLoading && (
                 <div className="mt-4 flex flex-col items-start gap-2 animate-fade-in-up w-full">
                    {suggestions.map((suggestion, idx) => (
                        <button 
                            key={idx} 
                            onClick={() => onSendSuggestion(suggestion)} 
                            className="inline-flex items-center justify-center gap-2 whitespace-nowrap font-medium transition-colors focus-visible:outline-none disabled:pointer-events-none disabled:opacity-50 h-9 rounded-xl px-3.5 py-1.5 text-sm text-muted-foreground hover:text-foreground hover:bg-surface-l2 border border-transparent hover:border-border"
                        >
                            <CornerDownRightIcon className="size-3.5 text-muted-foreground" />
                            <span className="truncate max-w-[300px]">{suggestion}</span>
                        </button>
                    ))}
                </div>
            )}
        </div>
    );
};

export default ChatMessage;
```

================================================================================
PART 3: GENERATIVE UI WIDGET
================================================================================

## Source Code (`components/GenerativeUI.tsx`)

```tsx
import React, { useEffect, useRef, useState } from 'react';
import { BarChartIcon } from './icons';

interface GenerativeUIProps {
    toolName: string;
    args: any;
}

// Wrapper for Plotly charts
const ChartRenderer: React.FC<{ type: string; data: any; title?: string; height?: string; colors?: string[] }> = ({ type, data, title, height, colors }) => {
    const chartRef = useRef<HTMLDivElement>(null);

    useEffect(() => {
        if (!window.Plotly || !chartRef.current || !data) return;

        let plotData: any[] = [];
        // Generic dark mode config
        let layout: any = { 
            title: title ? { text: title, font: { color: '#e4e4e4' } } : undefined,
            autosize: true,
            paper_bgcolor: 'rgba(0,0,0,0)',
            plot_bgcolor: 'rgba(0,0,0,0)',
            font: { color: '#888' },
            margin: { t: title ? 30 : 10, r: 10, l: 30, b: 30 },
            xaxis: { gridcolor: '#333', zerolinecolor: '#333' },
            yaxis: { gridcolor: '#333', zerolinecolor: '#333' },
            showlegend: false,
        };

        const defaultColor = colors ? colors[0] : '#1d9bf0';

        try {
            if (type === 'line' || type === 'bar') {
                if (Array.isArray(data)) {
                     plotData = data.map((trace: any, i: number) => ({ 
                        ...trace, 
                        type: type,
                        marker: { color: colors ? colors[i % colors.length] : defaultColor },
                        line: { color: colors ? colors[i % colors.length] : defaultColor, width: 2 }
                    }));
                } else if (data.x && data.y) {
                     plotData = [{ x: data.x, y: data.y, type: type, marker: { color: defaultColor }, line: { color: defaultColor, width: 2 } }];
                }
            } else if (type === 'pie' || type === 'donut') {
                 if (Array.isArray(data) && data[0]?.labels && data[0]?.values) {
                     plotData = data.map((trace: any) => ({ ...trace, type: 'pie', hole: type === 'donut' ? 0.6 : 0 }));
                 } else if (data && data.labels && data.values) {
                     plotData = [{ ...data, type: 'pie', hole: type === 'donut' ? 0.6 : 0 }];
                 }
            }

            if (plotData.length > 0) {
                window.Plotly.react(chartRef.current, plotData, layout, { responsive: true, displayModeBar: false });
            }
        } catch (e) {
            console.error("Chart rendering failed", e);
        }

    }, [type, data, title, colors]);

    return (
        <div style={{ height: height || '320px' }} className="w-full">
            <div ref={chartRef} className="w-full h-full" />
        </div>
    );
};

const StockWidget: React.FC<{ symbol: string; price: string; change: string; changePercent: string; chartData: any; history?: any; stats: any; currency?: string; }> = ({ symbol = 'N/A', price = '0.00', change = '', changePercent = '', chartData, history = {}, stats = {}, currency = '$' }) => {
    const safeChange = String(change || '0.00');
    const safeChangePercent = String(changePercent || '0.00%');
    const isNegative = safeChange.includes('-') || safeChangePercent.includes('-');
    const trendColor = isNegative ? 'text-[#ef4444]' : 'text-[#22c55e]';
    const chartColor = isNegative ? '#ef4444' : '#22c55e';
    const [activeRange, setActiveRange] = useState('1D');

    const currentData = React.useMemo(() => {
        if (activeRange === '1D') return chartData;
        if (history && history[activeRange]) return history[activeRange];
        return chartData;
    }, [activeRange, chartData, history]);

    return (
        <div className="bg-[#121212] border border-[#27272a] rounded-xl overflow-hidden shadow-lg my-4 max-w-3xl font-sans text-[#e4e4e7]">
            <div className="p-5 flex flex-wrap justify-between items-start gap-4">
                <div>
                    <div className="text-sm text-[#a1a1aa] font-medium mb-1">{symbol}</div>
                    <div className="text-5xl font-bold tracking-tight mb-2 text-white">{currency}{price}</div>
                    <div className={`text-sm font-medium ${trendColor} flex items-center gap-1.5`}>
                        <span className="font-bold">{safeChange}</span> 
                        <span>({safeChangePercent})</span>
                    </div>
                </div>
                <div className="flex bg-[#27272a] rounded-lg overflow-hidden p-1 self-center">
                    {['1D', '5D', '1M', '6M', '1Y', '5Y'].map(r => (
                        <button 
                            key={r}
                            onClick={() => setActiveRange(r)}
                            disabled={r !== '1D' && (!history || !history[r])}
                            className={`px-3 py-1.5 text-xs font-semibold rounded-md transition-colors ${activeRange === r ? 'bg-[#3f3f46] text-white' : 'text-[#a1a1aa] hover:text-white hover:bg-white/5 disabled:opacity-30 disabled:cursor-not-allowed'}`}
                        >
                            {r}
                        </button>
                    ))}
                </div>
            </div>
            <div className="h-[340px] w-full px-2 relative">
                 <ChartRenderer type="line" data={currentData} height="340px" colors={[chartColor]} />
            </div>
            {stats && Object.keys(stats).length > 0 && (
                <div className="bg-[#18181b] border-t border-[#27272a] p-5 grid grid-cols-2 sm:grid-cols-3 gap-y-4 gap-x-12">
                    {Object.entries(stats).map(([key, value]) => (
                        <div key={key} className="flex justify-between items-center text-sm">
                            <span className="text-[#a1a1aa] font-normal">{key}</span>
                            <span className="text-white font-medium">{String(value || '-')}</span>
                        </div>
                    ))}
                </div>
            )}
        </div>
    );
};

const GenerativeUI: React.FC<GenerativeUIProps> = ({ toolName, args }) => {
    if (!args) return null;
    if (toolName === 'render_stock_widget') {
        return <StockWidget 
            symbol={args.symbol} price={args.price} change={args.change} 
            changePercent={args.changePercent} chartData={args.chartData} 
            history={args.history} stats={args.stats} currency={args.currency}
        />;
    }
    
    // Default fallback for unknown tools
    return (
        <div className="p-4 bg-gray-50 dark:bg-[#252525] border border-gray-200 dark:border-[#333] rounded-lg my-2">
            <div className="flex items-center gap-2 mb-2">
                <BarChartIcon className="size-4 text-blue-500" />
                <span className="text-xs font-mono text-gray-500 uppercase">{toolName}</span>
            </div>
            <pre className="text-xs overflow-x-auto text-gray-600 dark:text-gray-300">
                {JSON.stringify(args, null, 2)}
            </pre>
        </div>
    );
};

export default GenerativeUI;
```
